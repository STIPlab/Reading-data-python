{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6ebeef88",
   "metadata": {},
   "outputs": [],
   "source": [
    "pip install pandas numpy matplotlib seaborn networkx "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3c741268",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary Python libraries\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import networkx as nx\n",
    "\n",
    "# Set style for better visualizations\n",
    "plt.style.use('default')\n",
    "sns.set_palette(\"husl\")\n",
    "\n",
    "# Load the dataset from OECD STIP Survey with error handling\n",
    "# url = \"https://stip-pp.oecd.org/assets/downloads/STIP_Survey.csv\"\n",
    "url = \"STIP_Survey.csv\"\n",
    "# Use low_memory=False to handle parsing issues and add error handling\n",
    "try:\n",
    "    stip_survey = pd.read_csv(url, sep=\"|\", low_memory=False)\n",
    "    print(\"Data loaded successfully!\")\n",
    "except Exception as e:\n",
    "    print(f\"Error loading data: {e}\")\n",
    "    print(\"Trying alternative approach...\")\n",
    "    \n",
    "    # Alternative approach with different parameters\n",
    "    try:\n",
    "        stip_survey = pd.read_csv(url, sep=\"|\", low_memory=False, on_bad_lines='skip')\n",
    "        print(\"Data loaded with error handling!\")\n",
    "    except Exception as e2:\n",
    "        print(f\"Alternative approach also failed: {e2}\")\n",
    "        raise\n",
    "\n",
    "# Display basic information about the dataset\n",
    "print(\"\\nNumber of rows in the dataset:\", len(stip_survey))\n",
    "print(\"\\nFirst 5 rows of the dataset:\")\n",
    "print(stip_survey.head())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "508200ae",
   "metadata": {},
   "outputs": [],
   "source": [
    "#To facilitate working with the dataset, we generate a separate 'Codebook' dataframe listing the column names and the detail given in the first row, for variables on themes and direct beneficiaries\n",
    "\n",
    "# 1. Get column names (Code) and the first row (Meaning) from the DataFrame\n",
    "columns = stip_survey.columns\n",
    "meanings = stip_survey.iloc[0].values\n",
    "\n",
    "# 2. Create a DataFrame pairing each column name with its description\n",
    "codebook = pd.DataFrame({\n",
    "    \"Code\": columns,\n",
    "    \"Meaning\": meanings\n",
    "})\n",
    "\n",
    "# 3. Filter only columns whose names start with \"TH\" or \"TG\" (policy themes and direct beneficiaries)\n",
    "codebook = codebook[codebook[\"Code\"].str.match(r\"^TH|^TG\")].reset_index(drop=True)\n",
    "\n",
    "# 4. Display the first 10 rows of the codebook\n",
    "codebook.head(10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "65ded1e7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Data preprocessing\n",
    "# Remove the description row to keep only observational data\n",
    "stip_survey = stip_survey.iloc[1:].reset_index(drop=True)\n",
    "\n",
    "# Convert theme and target group columns to numeric format\n",
    "th_tg_cols = [col for col in stip_survey.columns if col.startswith('TH') or col.startswith('TG')]\n",
    "stip_survey[th_tg_cols] = stip_survey[th_tg_cols].apply(pd.to_numeric, errors='coerce').fillna(0)\n",
    "\n",
    "# Create a separate DataFrame with unique initiatives only\n",
    "stip_survey_unique = stip_survey.drop_duplicates(subset=['InitiativeID']).copy()\n",
    "\n",
    "print(\"Data loaded and prepared.\")\n",
    "print(f\"Total policy instruments (rows): {len(stip_survey)}\")\n",
    "print(f\"Total unique policy initiatives: {len(stip_survey_unique)}\")\n",
    "stip_survey_unique.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "34f11604",
   "metadata": {},
   "outputs": [],
   "source": [
    "th31_initiatives = stip_survey_unique[stip_survey_unique['TH31'] == 1]\n",
    "\n",
    "# 2. Count the number of initiatives per country and get the top 10\n",
    "top_countries_th31 = th31_initiatives['CountryLabel'].value_counts().head(10)\n",
    "\n",
    "# 3. Print the resulting counts\n",
    "print(\"Top 10 countries by number of initiatives for 'Financial support to business R&D':\")\n",
    "print(top_countries_th31)\n",
    "\n",
    "# 4. Visualize the results using a bar chart for better comparison\n",
    "plt.figure(figsize=(12, 7))\n",
    "sns.barplot(x=top_countries_th31.values, y=top_countries_th31.index, color='steelblue')\n",
    "plt.title('Top 10 Countries by Number of Initiatives in \"Financial support to business R&D\"')\n",
    "plt.xlabel('Number of Unique Initiatives')\n",
    "plt.ylabel('Country')\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5b37cff5",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "# 1. Define the governance themes to analyze (use correct codes)\n",
    "# New themes + related themes with high co-occurrence potential\n",
    "governance_themes = [\n",
    "    # New themes\n",
    "    'TH111',  # Strategic autonomy and promotion of critical technologies\n",
    "    'TH110',  # Dynamic skills and capabilities for policymaking\n",
    "    'TH112',  # Net zero transitions in steel\n",
    "    \n",
    "    # Related themes with high co-occurrence potential\n",
    "    'TH34',   # Dynamic and entrepreneurial capabilities and culture\n",
    "    'TH13',   # STI plan or strategy\n",
    "    'TH15',   # Evaluation and impact assessment\n",
    "    'TH22',   # Structural change in the public research system\n",
    "    \n",
    "    # Additional themes that likely co-occur with new themes\n",
    "    'TH31',   # Financial support to business R&D and innovation\n",
    "    'TH32',   # Non-financial support to business R&D and innovation\n",
    "    'TH82',   # Digital transformation of firms\n",
    "    'TH91',   # Mission-oriented innovation policies\n",
    "    'TH92',   # Net zero transitions in energy\n",
    "    'TH103',  # Net zero transitions in transport and mobility\n",
    "    'TH104',  # Net zero transitions in food and agriculture\n",
    "    'TH89',   # Ethics and governance of emerging technologies\n",
    "    'TH106',  # Digital transformation of research-performing organisations\n",
    "    'TH109'   # Research security\n",
    "]\n",
    "\n",
    "# 2. English labels for the heatmap\n",
    "label_mapping = {\n",
    "    # New themes\n",
    "    'TH111': 'Strategic Autonomy & Critical Technologies',\n",
    "    'TH110': 'Dynamic Skills for Policymaking',\n",
    "    'TH112': 'Net Zero Transitions in Steel',\n",
    "    \n",
    "    # Related themes\n",
    "    'TH34': 'Dynamic & Entrepreneurial Capabilities',\n",
    "    'TH13': 'STI Plan/Strategy',\n",
    "    'TH15': 'Evaluation & Impact Assessment',\n",
    "    'TH22': 'Structural Change in Public Research',\n",
    "    \n",
    "    # Additional related themes\n",
    "    'TH31': 'Financial Support to Business R&D',\n",
    "    'TH32': 'Non-financial Support to Business R&D',\n",
    "    'TH82': 'Digital Transformation of Firms',\n",
    "    'TH91': 'Mission-oriented Innovation Policies',\n",
    "    'TH92': 'Net Zero Transitions in Energy',\n",
    "    'TH103': 'Net Zero Transitions in Transport',\n",
    "    'TH104': 'Net Zero Transitions in Food & Agriculture',\n",
    "    'TH89': 'Ethics & Governance of Emerging Tech',\n",
    "    'TH106': 'Digital Transformation of Research Org',\n",
    "    'TH109': 'Research Security'\n",
    "}\n",
    "\n",
    "# 3. Check which themes are available in the dataset\n",
    "available_themes = [theme for theme in governance_themes if theme in stip_survey_unique.columns]\n",
    "print(f\"Available themes in dataset: {len(available_themes)} out of {len(governance_themes)}\")\n",
    "print(f\"Available themes: {available_themes}\")\n",
    "\n",
    "# 4. Create a DataFrame containing only available theme columns\n",
    "governance_df = stip_survey_unique[available_themes].copy()\n",
    "governance_df.columns = [label_mapping[col] for col in governance_df.columns]\n",
    "\n",
    "# 5. Calculate the co-occurrence matrix\n",
    "co_occurrence_matrix = governance_df.T.dot(governance_df)\n",
    "\n",
    "# 6. Draw the heatmap with inverted color scheme\n",
    "plt.figure(figsize=(16, 12))\n",
    "sns.heatmap(co_occurrence_matrix, \n",
    "            annot=True, \n",
    "            fmt='d', \n",
    "            cmap='viridis_r',  # Blue color scheme inverted\n",
    "            cbar_kws={'label': 'Number of Co-occurrences'})\n",
    "plt.title('Co-occurrence Heatmap: New Themes and Related Policy Areas\\n(Lighter colors = Lower relationship strength)', \n",
    "          fontsize=16, fontweight='bold')\n",
    "plt.xticks(rotation=45, ha='right')\n",
    "plt.yticks(rotation=0)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "# 7. Print summary of co-occurrence patterns\n",
    "print(\"\\nCo-occurrence Analysis Summary:\")\n",
    "print(\"=\" * 60)\n",
    "print(\"New Themes (TH111, TH110, TH112) co-occurrence patterns:\")\n",
    "\n",
    "# Focus on new themes\n",
    "new_themes = ['TH111', 'TH110', 'TH112']\n",
    "for new_theme in new_themes:\n",
    "    if new_theme in available_themes:\n",
    "        theme_label = label_mapping[new_theme]\n",
    "        print(f\"\\n{theme_label}:\")\n",
    "        \n",
    "        # Get co-occurrence values for this theme\n",
    "        theme_co_occurrences = co_occurrence_matrix.loc[label_mapping[new_theme]]\n",
    "        \n",
    "        # Sort by co-occurrence value (descending)\n",
    "        sorted_co_occurrences = theme_co_occurrences.sort_values(ascending=False)\n",
    "        \n",
    "        # Show top 5 co-occurring themes\n",
    "        print(\"Top 5 co-occurring themes:\")\n",
    "        # 修正: .items()を使用してキーと値のペアを取得\n",
    "        for i, (theme, value) in enumerate(sorted_co_occurrences.head(6)[1:].items(), 1):\n",
    "            print(f\"  {i}. {theme}: {value} initiatives\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c5585df3",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "import pandas as pd\n",
    "import networkx as nx\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# 1. Filter for instruments belonging to initiatives with the target theme.\n",
    "dynamic_skills_instruments = stip_survey[stip_survey['TH34'] == 1]\n",
    "\n",
    "# 2. Create a DataFrame of the relationships (edges) between countries and instruments.\n",
    "#    We drop any rows with missing values in these key columns.\n",
    "edges = dynamic_skills_instruments[['CountryLabel', 'InstrumentTypeLabel']].dropna().reset_index(drop=True)\n",
    "\n",
    "# 3. Create a graph object from this list of edges using the networkx library.\n",
    "G = nx.from_pandas_edgelist(edges, source='CountryLabel', target='InstrumentTypeLabel')\n",
    "\n",
    "# 4. Prepare for plotting by defining node properties.\n",
    "plt.figure(figsize=(16, 16)) # Use a large figure size for clarity\n",
    "pos = nx.spring_layout(G, k=0.4, iterations=50) # Position nodes using a force-directed layout\n",
    "\n",
    "# Differentiate nodes by type (country vs. instrument) for better visual interpretation.\n",
    "node_colors = []\n",
    "node_sizes = []\n",
    "country_nodes = edges['CountryLabel'].unique()\n",
    "\n",
    "for node in G.nodes():\n",
    "    if node in country_nodes:\n",
    "        node_colors.append('skyblue') # Color for countries\n",
    "        node_sizes.append(2000)\n",
    "    else:\n",
    "        node_colors.append('lightgreen') # Color for instruments\n",
    "        node_sizes.append(4000) # Larger nodes for instrument labels\n",
    "\n",
    "# 5. Draw the network graph.\n",
    "nx.draw(G, pos, \n",
    "        with_labels=True, \n",
    "        node_color=node_colors, \n",
    "        node_size=node_sizes,\n",
    "        font_size=10, \n",
    "        font_weight='bold', \n",
    "        edge_color='gray',\n",
    "        width=0.5)\n",
    "\n",
    "plt.title('Network of Countries and Policy Instruments for \"Dynamic Skills in Policymaking\"', size=20)\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b71b3180",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import networkx as nx\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from collections import Counter\n",
    "\n",
    "# Configuration\n",
    "categories = {\n",
    "    'New': ['TH110', 'TH111', 'TH112'],\n",
    "    'Governance': ['TH11', 'TH13', 'TH9', 'TH14', 'TH15', 'TH63', 'TH91', 'TH89', 'TH65'],\n",
    "    'Research': ['TH16', 'TH18', 'TH19', 'TH20', 'TH27', 'TH22', 'TH106', 'TH107', 'TH108', 'TH24', 'TH25', 'TH26', 'TH23', 'TH21', 'TH109'],\n",
    "    'Innovation': ['TH28', 'TH30', 'TH31', 'TH32', 'TH38', 'TH34', 'TH33', 'TH82', 'TH36', 'TH35'],\n",
    "    'Knowledge': ['TH39', 'TH41', 'TH42', 'TH47', 'TH43', 'TH44', 'TH46'],\n",
    "    'HR': ['TH48', 'TH50', 'TH51', 'TH52', 'TH53', 'TH55', 'TH54'],\n",
    "    'Society': ['TH56', 'TH58', 'TH61', 'TH66'],\n",
    "    'Net Zero': [ 'TH102', 'TH92', 'TH103', 'TH104']\n",
    "}\n",
    "colors = ['lightblue', 'red', 'green', 'blue', 'orange', 'purple', 'brown', 'darkgreen']\n",
    "\n",
    "# Get available themes\n",
    "themes = [t for cat in categories.values() for t in cat if t in stip_survey_unique.columns]\n",
    "new_themes = ['TH110', 'TH111', 'TH112']\n",
    "\n",
    "print(f\"Available themes: {len(themes)}\")\n",
    "print(f\"New themes: {[t for t in new_themes if t in themes]}\")\n",
    "\n",
    "# Create network relationships\n",
    "relationships = []\n",
    "for _, row in stip_survey_unique.iterrows():\n",
    "    active = [t for t in themes if row[t] == 1]\n",
    "    for i in range(len(active)):\n",
    "        for j in range(i+1, len(active)):\n",
    "            relationships.append((active[i], active[j]))\n",
    "\n",
    "weights = Counter(relationships)\n",
    "\n",
    "# Create graph\n",
    "G = nx.Graph()\n",
    "G.add_nodes_from(themes)\n",
    "for (t1, t2), w in weights.items():\n",
    "    if w >= 2:  # Only connections with 2+ co-occurrences\n",
    "        G.add_edge(t1, t2, weight=w)\n",
    "\n",
    "# Visualization setup\n",
    "plt.figure(figsize=(20, 16))\n",
    "pos = nx.spring_layout(G, k=2.0, seed=42)\n",
    "\n",
    "# Node colors and labels\n",
    "node_colors = []\n",
    "node_labels = {}\n",
    "for node in G.nodes():\n",
    "    for i, (cat, cat_themes) in enumerate(categories.items()):\n",
    "        if node in cat_themes:\n",
    "            node_colors.append(colors[i])\n",
    "            node_labels[node] = f\"{node}\\n({cat})\" if cat != 'New' else f\"{node}\\n(NEW)\"\n",
    "            break\n",
    "\n",
    "# Draw graph\n",
    "edge_weights = [G[u][v]['weight'] for u, v in G.edges()] if G.edges() else []\n",
    "max_w = max(edge_weights) if edge_weights else 1\n",
    "edge_widths = [w/max_w * 5 for w in edge_weights]\n",
    "node_sizes = [G.degree(n) * 200 for n in G.nodes()]\n",
    "\n",
    "nx.draw(G, pos, with_labels=True, labels=node_labels, node_color=node_colors, \n",
    "        node_size=node_sizes, font_size=7, font_weight='bold', edge_color='gray',\n",
    "        width=edge_widths, alpha=0.8)\n",
    "\n",
    "# Legend\n",
    "legend = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=colors[i], \n",
    "                     markersize=15, label=cat) for i, cat in enumerate(categories.keys())]\n",
    "plt.legend(handles=legend, loc='upper left', bbox_to_anchor=(1, 1), fontsize=10)\n",
    "plt.title('Policy Theme Network Analysis\\n(TH110,111,112 in Light Blue)\\nNode size = Connections, Edge thickness = Co-occurrence strength', \n",
    "          fontsize=16, fontweight='bold')\n",
    "plt.tight_layout()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "92ff8a08",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Net Zero Transitions Comparison Analysis\n",
    "# Create timeline comparison for TH102, TH92, TH103, TH104, and TH112\n",
    "\n",
    "# Theme codes and labels based on the CSV reference\n",
    "theme_codes = {\n",
    "    'TH102': 'Government Capabilities for Net Zero Transitions',\n",
    "    'TH92': 'Net Zero Transitions in Energy', \n",
    "    'TH103': 'Net Zero Transitions in Transport and Mobility',\n",
    "    'TH104': 'Net Zero Transitions in Food and Agriculture',\n",
    "    'TH112': 'Net Zero Transitions in Steel'\n",
    "}\n",
    "\n",
    "# Collect timeline data for each theme\n",
    "timeline_dict = {}\n",
    "available_themes = []\n",
    "\n",
    "for code, label in theme_codes.items():\n",
    "    if code in stip_survey_unique.columns:\n",
    "        available_themes.append(code)\n",
    "        # Filter initiatives for this theme\n",
    "        initiatives = stip_survey_unique[stip_survey_unique[code] == 1].copy()\n",
    "        \n",
    "        if len(initiatives) > 0:\n",
    "            # Convert StartDateYear to numeric\n",
    "            initiatives['StartDateYear'] = pd.to_numeric(initiatives['StartDateYear'], errors='coerce')\n",
    "            initiatives = initiatives.dropna(subset=['StartDateYear'])\n",
    "            initiatives = initiatives[initiatives['StartDateYear'] > 2000]\n",
    "            \n",
    "            if len(initiatives) > 0:\n",
    "                timeline = initiatives['StartDateYear'].value_counts().sort_index()\n",
    "                timeline_dict[label] = timeline\n",
    "                print(f\"{code}: {len(initiatives)} initiatives found\")\n",
    "            else:\n",
    "                print(f\"{code}: No initiatives in specified time frame\")\n",
    "        else:\n",
    "            print(f\"{code}: No initiatives found\")\n",
    "    else:\n",
    "        print(f\"{code}: Theme not available in dataset\")\n",
    "\n",
    "# Create comparison plot\n",
    "if len(timeline_dict) > 1:\n",
    "    plt.figure(figsize=(14, 8))\n",
    "    \n",
    "    # Define colors for better visualization\n",
    "    colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']\n",
    "    \n",
    "    for i, (label, timeline) in enumerate(timeline_dict.items()):\n",
    "        color = colors[i % len(colors)]\n",
    "        plt.plot(timeline.index, timeline.values, marker='o', linestyle='-', \n",
    "                label=label, linewidth=2, markersize=6, color=color)\n",
    "    \n",
    "    plt.title('Comparison of Net Zero Transition Initiatives Timeline', fontsize=16, fontweight='bold')\n",
    "    plt.xlabel('Year of Introduction', fontsize=12)\n",
    "    plt.ylabel('Number of New Initiatives', fontsize=12)\n",
    "    plt.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.7)\n",
    "    plt.xticks(rotation=45)\n",
    "    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Print summary statistics\n",
    "    print(\"\\nSummary of Net Zero Transition Initiatives:\")\n",
    "    print(\"=\" * 50)\n",
    "    for label, timeline in timeline_dict.items():\n",
    "        total_initiatives = timeline.sum()\n",
    "        years_active = len(timeline)\n",
    "        peak_year = timeline.idxmax()\n",
    "        peak_count = timeline.max()\n",
    "        print(f\"{label}:\")\n",
    "        print(f\"  Total initiatives: {total_initiatives}\")\n",
    "        print(f\"  Years active: {years_active}\")\n",
    "        print(f\"  Peak year: {peak_year} ({peak_count} initiatives)\")\n",
    "        print()\n",
    "        \n",
    "else:\n",
    "    print(\"Not enough themes available for comparison\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "532aa3de",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cbc8b922",
   "metadata": {},
   "outputs": [],
   "source": [
    " # Generate descriptive statistics for key year columns \n",
    "print(stip_survey[['SurveyYear', 'StartDateYear', 'EndDateYear']].describe())\n",
    "\n",
    " # Generate descriptive statistics for key year columns     \n",
    " # Count the number of unique policy initiatives per country \n",
    "# We use the 'stip_survey_unique' DataFrame to avoid overcounting \n",
    "top_countries = stip_survey_unique['CountryLabel'].value_counts() \n",
    " \n",
    "# Display the top 10 countries \n",
    "print(top_countries.head(10))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
